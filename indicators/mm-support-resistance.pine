// This Pine Script™ indicator is subject to the terms of the Mozilla Public License 2.0
// https://mozilla.org/MPL/2.0/
//
// Market Maker S/R Zones — MM Native Edition
//
// Support/Resistance zones scored entirely by market maker concepts:
//   - Zones created at auto-calibrated pivots (no fixed lengths)
//   - Tier scoring by: liquidity sweep, displacement, FVG overlap
//   - Smart flip: displacement through zone = strong flip, wick = potential sweep
//   - Zone lifecycle: retests weaken zones, sweeps invalidate them
//   - FVG imbalances create their own institutional zones
//
// NO volume SMA, RSI, or other retail indicators used.
//
// @version=5
indicator("MM S/R Zones", shorttitle="MM-SR", overlay=true,
     max_boxes_count=500, max_labels_count=500, max_lines_count=200)

// ══════════════════════════════════════════════════════════════════════════════
// INPUTS
// ══════════════════════════════════════════════════════════════════════════════

grp_zone     = "═══ Zone Detection ═══"
autoCalib    = input.bool(true, "Auto-Calibrate Pivot Lengths",     group=grp_zone,
                 tooltip="Derive pivot lengths from the instrument's own price rhythm. When OFF, use manual values.")
pivotLen_in  = input.int(8,  "Pivot Length (manual)",               group=grp_zone, minval=2, maxval=50,
                 tooltip="Only used when Auto-Calibrate is OFF.")
maxZones     = input.int(12, "Max Visible Zones", options=[6, 8, 10, 12, 16, 20], group=grp_zone)
zoneAtrMult  = input.float(0.4, "Zone Thickness (× ATR)",          group=grp_zone, minval=0.1, maxval=1.5, step=0.1,
                 tooltip="How thick each S/R zone box is, relative to ATR.")
maxRetests   = input.int(3,  "Max Retests Before Fade",            group=grp_zone, minval=1, maxval=10,
                 tooltip="After this many retests without a sweep, the zone fades out.")

grp_mm       = "═══ Market Maker Logic ═══"
useSweep     = input.bool(true, "Liquidity Sweep Scoring",         group=grp_mm,
                 tooltip="Zones that have been swept (stops taken) get promoted. A swept zone that holds = very strong.")
useDisplace  = input.bool(true, "Displacement Scoring",            group=grp_mm,
                 tooltip="Zones created after a displacement candle (body > 70% range) score higher.")
dispBodyPct  = input.float(70,  "  Min Body %",                    group=grp_mm, minval=50, maxval=95, step=5)
useFVGzones  = input.bool(true, "FVG as S/R Zones",                group=grp_mm,
                 tooltip="Fair Value Gaps create their own institutional S/R zones.")
showFVGzones = input.bool(true, "  Show FVG Zones",                group=grp_mm)
useChoch     = input.bool(true, "CHoCH Awareness",                 group=grp_mm,
                 tooltip="After a Change of Character, zones in the new direction get boosted.")

grp_vis      = "═══ Visual ═══"
baseSupColor = input.color(#00E676, "Support Color",                group=grp_vis)
baseResColor = input.color(#FF5252, "Resistance Color",             group=grp_vis)
fvgSupColor  = input.color(color.new(#7C4DFF, 0), "FVG Zone Color", group=grp_vis)
t1TextColor  = input.color(color.white, "T1 Label Color",          group=grp_vis)
showLabels   = input.bool(true, "Show Tier Labels",                group=grp_vis)

// ══════════════════════════════════════════════════════════════════════════════
// AUTO-CALIBRATION ENGINE
// ══════════════════════════════════════════════════════════════════════════════

var array<int> runLengths = array.new_int(0)
var int currentRun = 1
var int currentDir = 0

runDir = close > close[1] ? 1 : close < close[1] ? -1 : currentDir
if runDir == currentDir or currentDir == 0
    currentRun += 1
    currentDir := runDir != 0 ? runDir : currentDir
else
    if currentRun > 0
        array.push(runLengths, currentRun)
        if array.size(runLengths) > 200
            array.shift(runLengths)
    currentRun := 1
    currentDir := runDir

calibPivot() =>
    if array.size(runLengths) < 20
        8
    else
        sum = 0.0
        sz = array.size(runLengths)
        for i = 0 to sz - 1
            sum += array.get(runLengths, i)
        avg = sum / sz
        // Pivot length = ~2.5× average run (captures one structural level)
        math.max(math.round(avg * 2.5), 3)

calPivot = calibPivot()
pivotLen = autoCalib ? calPivot : pivotLen_in

// ══════════════════════════════════════════════════════════════════════════════
// CORE DETECTION
// ══════════════════════════════════════════════════════════════════════════════

atrVal = ta.atr(14)

// Pivots
ph = ta.pivothigh(high, pivotLen, pivotLen)
pl = ta.pivotlow(low, pivotLen, pivotLen)

// Displacement detection (current bar)
candleRange  = high - low
candleBody   = math.abs(close - open)
bodyPct      = candleRange > 0 ? (candleBody / candleRange) * 100.0 : 0.0
isDispUp     = useDisplace and bodyPct >= dispBodyPct and close > open
isDispDown   = useDisplace and bodyPct >= dispBodyPct and close < open

// FVG detection
bullFVG      = useFVGzones and low > high[2]
bearFVG      = useFVGzones and high < low[2]

// CHoCH state tracking
var float lastSwingHi = na
var float lastSwingLo = na
var int   trendDir    = 0  // 1=bullish, -1=bearish

if not na(ph)
    lastSwingHi := ph
if not na(pl)
    lastSwingLo := pl

chochBull = useChoch and not na(lastSwingHi) and trendDir == -1 and close > lastSwingHi
chochBear = useChoch and not na(lastSwingLo) and trendDir == 1  and close < lastSwingLo

if chochBull
    trendDir := 1
if chochBear
    trendDir := -1
if trendDir == 0
    trendDir := close > close[20] ? 1 : -1

// ══════════════════════════════════════════════════════════════════════════════
// ZONE DATA STRUCTURE
// ══════════════════════════════════════════════════════════════════════════════

type SRZone
    box      bx
    label    lbl
    float    price         // center price
    float    top           // zone top
    float    bot           // zone bottom
    bool     isRes         // true = resistance, false = support
    int      tier          // 1=Strong 2=Medium 3=Structural
    int      retests       // times price touched this zone
    bool     wasSwept      // a wick went through but price returned
    bool     hasDisp       // displacement candle was near this zone at creation
    bool     hasFVG        // FVG overlaps with this zone
    bool     isFVGzone     // this zone IS an FVG (not a pivot)
    int      createdBar    // bar_index at creation
    bool     active
    int      trendAtCreate // trend direction when zone was created

var array<SRZone> zones = array.new<SRZone>()

// ══════════════════════════════════════════════════════════════════════════════
// ZONE SCORING — MM NATIVE TIER CALCULATION
// ══════════════════════════════════════════════════════════════════════════════
//
// T1 (Strong): swept + held, OR displacement + FVG overlap, OR CHoCH-aligned + swept
// T2 (Medium): has displacement OR has FVG OR was swept once
// T3 (Structural): basic pivot with no MM confirmation

calcTier(bool swept, bool disp, bool fvg, bool chochAligned) =>
    score = 0
    if swept
        score += 2
    if disp
        score += 1
    if fvg
        score += 1
    if chochAligned
        score += 1
    score >= 3 ? 1 : score >= 1 ? 2 : 3

// ══════════════════════════════════════════════════════════════════════════════
// ZONE CREATION
// ══════════════════════════════════════════════════════════════════════════════

addPivotZone(bool isRes, float price, int pivotBar) =>
    if not na(atrVal) and atrVal > 0
        halfZone = atrVal * zoneAtrMult
        zTop = price + halfZone
        zBot = price - halfZone

        // Check overlap with existing zones — merge or skip
        skip = false
        if array.size(zones) > 0
            for i = 0 to array.size(zones) - 1
                z = array.get(zones, i)
                if z.active and math.abs(z.price - price) < (atrVal * 1.0)
                    skip := true  // too close to existing zone
                    break

        if not skip
            // Check for displacement near this pivot
            hasDisp = false
            for k = 0 to math.min(pivotLen, 5)
                bRange = high[pivotLen + k] - low[pivotLen + k]
                bBody  = math.abs(close[pivotLen + k] - open[pivotLen + k])
                if bRange > 0 and (bBody / bRange * 100.0) >= dispBodyPct
                    hasDisp := true
                    break

            // Check for FVG overlap near this pivot
            hasFVG = false
            for k = 0 to math.min(pivotLen, 5)
                if low[pivotLen + k] > high[pivotLen + k + 2] or high[pivotLen + k] < low[pivotLen + k + 2]
                    fvgMid = (low[pivotLen + k] + high[pivotLen + k + 2]) / 2.0
                    if math.abs(fvgMid - price) < atrVal
                        hasFVG := true
                        break

            chochAligned = (isRes and trendDir == -1) or (not isRes and trendDir == 1)
            tier = calcTier(false, hasDisp, hasFVG, chochAligned)

            bx = box.new(pivotBar, zTop, bar_index, zBot,
                 border_color=color.new(color.white, 100), bgcolor=color.new(color.white, 100))
            lbl = label.new(na, na, "", style=label.style_none, size=size.tiny)

            array.push(zones, SRZone.new(bx, lbl, price, zTop, zBot, isRes, tier,
                 0, false, hasDisp, hasFVG, false, bar_index, true, trendDir))

// Pivot zone triggers
if not na(ph)
    addPivotZone(true, ph, bar_index - pivotLen)
if not na(pl)
    addPivotZone(false, pl, bar_index - pivotLen)

// FVG zone creation
if bullFVG and showFVGzones
    fTop = low
    fBot = high[2]
    fMid = (fTop + fBot) / 2.0
    bx = box.new(bar_index - 2, fTop, bar_index, fBot,
         border_color=color.new(color.white, 100), bgcolor=color.new(color.white, 100))
    lbl = label.new(na, na, "", style=label.style_none, size=size.tiny)
    array.push(zones, SRZone.new(bx, lbl, fMid, fTop, fBot, false, 2,
         0, false, false, true, true, bar_index, true, trendDir))

if bearFVG and showFVGzones
    fTop = low[2]
    fBot = high
    fMid = (fTop + fBot) / 2.0
    bx = box.new(bar_index - 2, fTop, bar_index, fBot,
         border_color=color.new(color.white, 100), bgcolor=color.new(color.white, 100))
    lbl = label.new(na, na, "", style=label.style_none, size=size.tiny)
    array.push(zones, SRZone.new(bx, lbl, fMid, fTop, fBot, true, 2,
         0, false, false, true, true, bar_index, true, trendDir))

// ══════════════════════════════════════════════════════════════════════════════
// ZONE LIFECYCLE — RETEST, SWEEP, FLIP, INVALIDATION
// ══════════════════════════════════════════════════════════════════════════════

if array.size(zones) > 0
    for i = 0 to array.size(zones) - 1
        z = array.get(zones, i)
        if not z.active
            continue

        // ─── RETEST DETECTION ───
        // Price touches the zone but doesn't close through it
        touchesZone = (high >= z.bot and low <= z.top)
        closedAbove = close > z.top
        closedBelow = close < z.bot
        closedInside = close >= z.bot and close <= z.top

        if touchesZone and (closedInside or (z.isRes and closedBelow) or (not z.isRes and closedAbove))
            // This is a retest (touch + respect)
            if bar_index > z.createdBar + pivotLen  // don't count creation bar
                z.retests += 1

        // ─── SWEEP DETECTION ───
        // Wick goes through but close comes back = liquidity sweep
        if z.isRes and high > z.top and close < z.top
            z.wasSwept := true
            z.tier     := calcTier(true, z.hasDisp, z.hasFVG, (z.isRes and trendDir == -1) or (not z.isRes and trendDir == 1))
        if not z.isRes and low < z.bot and close > z.bot
            z.wasSwept := true
            z.tier     := calcTier(true, z.hasDisp, z.hasFVG, (z.isRes and trendDir == -1) or (not z.isRes and trendDir == 1))

        // ─── SMART FLIP ───
        // Displacement through = strong flip (institutional)
        // Slow drift through = weak flip (might reverse)
        if z.isRes and closedAbove
            // Check if this was a displacement candle
            if bodyPct >= dispBodyPct and close > open
                z.isRes := false  // strong flip to support
                z.hasDisp := true
                z.retests := 0   // reset retests on flip
                z.tier := calcTier(z.wasSwept, true, z.hasFVG, trendDir == 1)
            else
                z.isRes := false  // weak flip
                z.retests += 1   // count as additional wear

        if not z.isRes and closedBelow
            if bodyPct >= dispBodyPct and close < open
                z.isRes := true   // strong flip to resistance
                z.hasDisp := true
                z.retests := 0
                z.tier := calcTier(z.wasSwept, true, z.hasFVG, trendDir == -1)
            else
                z.isRes := true   // weak flip
                z.retests += 1

        // ─── INVALIDATION ───
        // Zone fades after too many retests (it's "used up")
        if z.retests >= maxRetests
            z.tier := 3  // demote to structural before eventual removal

        // Remove very old, weak, heavily retested zones
        if z.retests >= maxRetests + 2
            box.delete(z.bx)
            label.delete(z.lbl)
            z.active := false

// ══════════════════════════════════════════════════════════════════════════════
// DISPLAY — RANKING & RENDERING
// ══════════════════════════════════════════════════════════════════════════════

if barstate.islast
    // Build visible list
    var array<SRZone> visible = array.new<SRZone>()
    array.clear(visible)

    if array.size(zones) > 0
        for i = 0 to array.size(zones) - 1
            z = array.get(zones, i)
            if z.active
                array.push(visible, z)

    // Sort by relevance: (distance from price) × tier × retest penalty
    if array.size(visible) > 1
        for i = 0 to array.size(visible) - 2
            for j = i + 1 to array.size(visible) - 1
                z1 = array.get(visible, i)
                z2 = array.get(visible, j)
                dist1 = math.abs(close - z1.price)
                dist2 = math.abs(close - z2.price)
                // Lower = better: close zones + low tier number + few retests
                score1 = dist1 * z1.tier * (1.0 + z1.retests * 0.3)
                score2 = dist2 * z2.tier * (1.0 + z2.retests * 0.3)
                if score1 > score2
                    array.set(visible, i, z2)
                    array.set(visible, j, z1)

    showCount = math.min(array.size(visible), maxZones)

    // First: reset all zones to invisible
    if array.size(zones) > 0
        for i = 0 to array.size(zones) - 1
            z = array.get(zones, i)
            if z.active
                box.set_bgcolor(z.bx, color.new(color.white, 100))
                box.set_border_color(z.bx, color.new(color.white, 100))
                box.set_right(z.bx, bar_index + 15)
                label.set_xy(z.lbl, na, na)
                label.set_text(z.lbl, "")

    // Then: render top N
    if showCount > 0
        for i = 0 to showCount - 1
            z = array.get(visible, i)

            // Color by type
            color baseCol = z.isFVGzone ? fvgSupColor :
                 (z.isRes ? baseResColor : baseSupColor)

            // Transparency by tier + retest wear
            float baseTr = z.tier == 1 ? 20.0 : z.tier == 2 ? 50.0 : 80.0
            float retestFade = math.min(z.retests * 8.0, 15.0)
            float finalTr = math.min(baseTr + retestFade, 92.0)

            box.set_bgcolor(z.bx, color.new(baseCol, finalTr))
            box.set_border_color(z.bx, color.new(baseCol, math.max(finalTr - 15.0, 0.0)))
            box.set_border_width(z.bx, z.tier == 1 ? 2 : 1)
            box.set_right(z.bx, bar_index + 15)

            // Label
            if showLabels
                tierStr = z.tier == 1 ? "T1" : z.tier == 2 ? "T2" : ""
                badges = ""
                if z.wasSwept
                    badges := badges + " SW"
                if z.hasDisp
                    badges := badges + " D"
                if z.hasFVG or z.isFVGzone
                    badges := badges + " FVG"
                if z.retests > 0
                    badges := badges + " R:" + str.tostring(z.retests)

                fullText = tierStr + badges

                if str.length(fullText) > 0
                    label.set_xy(z.lbl, bar_index + 16, z.price)
                    label.set_text(z.lbl, fullText)
                    label.set_style(z.lbl, label.style_label_left)
                    label.set_color(z.lbl, color.new(baseCol, 30))
                    label.set_textcolor(z.lbl, z.tier == 1 ? t1TextColor : color.new(color.white, 20))
                    label.set_size(z.lbl, z.tier == 1 ? size.small : size.tiny)

// ══════════════════════════════════════════════════════════════════════════════
// INFO TABLE
// ══════════════════════════════════════════════════════════════════════════════

if barstate.islast
    var table tbl = table.new(position.top_right, 2, 8,
         bgcolor=color.new(#1A1A2E, 10), frame_color=color.new(#FFFFFF, 70),
         frame_width=1, border_color=color.new(#FFFFFF, 85), border_width=1)

    table.cell(tbl, 0, 0, "MM S/R Zones", text_color=color.white, text_size=size.small, text_halign=text.align_left)
    table.cell(tbl, 1, 0, "[MM Native]",  text_color=color.gray,  text_size=size.tiny,  text_halign=text.align_right)

    calibStr = autoCalib ? "Auto: " + str.tostring(pivotLen) : "Manual: " + str.tostring(pivotLen)
    table.cell(tbl, 0, 1, "Pivot length:", text_color=#00BCD4, text_size=size.tiny, text_halign=text.align_left)
    table.cell(tbl, 1, 1, calibStr,       text_color=#00BCD4, text_size=size.tiny, text_halign=text.align_right)

    // Count active zones by tier
    t1count = 0
    t2count = 0
    t3count = 0
    fvgcount = 0
    sweepcount = 0
    if array.size(zones) > 0
        for i = 0 to array.size(zones) - 1
            z = array.get(zones, i)
            if z.active
                if z.tier == 1
                    t1count += 1
                else if z.tier == 2
                    t2count += 1
                else
                    t3count += 1
                if z.isFVGzone
                    fvgcount += 1
                if z.wasSwept
                    sweepcount += 1

    table.cell(tbl, 0, 2, "T1 (Strong):",  text_color=#4CAF50, text_size=size.tiny, text_halign=text.align_left)
    table.cell(tbl, 1, 2, str.tostring(t1count), text_color=#4CAF50, text_size=size.tiny, text_halign=text.align_right)

    table.cell(tbl, 0, 3, "T2 (Medium):",  text_color=#FF9800, text_size=size.tiny, text_halign=text.align_left)
    table.cell(tbl, 1, 3, str.tostring(t2count), text_color=#FF9800, text_size=size.tiny, text_halign=text.align_right)

    table.cell(tbl, 0, 4, "T3 (Struct.):", text_color=#78909C, text_size=size.tiny, text_halign=text.align_left)
    table.cell(tbl, 1, 4, str.tostring(t3count), text_color=#78909C, text_size=size.tiny, text_halign=text.align_right)

    table.cell(tbl, 0, 5, "FVG zones:",    text_color=#7C4DFF, text_size=size.tiny, text_halign=text.align_left)
    table.cell(tbl, 1, 5, str.tostring(fvgcount), text_color=#7C4DFF, text_size=size.tiny, text_halign=text.align_right)

    table.cell(tbl, 0, 6, "Swept zones:",  text_color=#FFEB3B, text_size=size.tiny, text_halign=text.align_left)
    table.cell(tbl, 1, 6, str.tostring(sweepcount), text_color=#FFEB3B, text_size=size.tiny, text_halign=text.align_right)

    trendStr = trendDir == 1 ? "Bullish" : "Bearish"
    trendCol = trendDir == 1 ? #26A69A : #EF5350
    table.cell(tbl, 0, 7, "Structure:",    text_color=trendCol, text_size=size.tiny, text_halign=text.align_left)
    table.cell(tbl, 1, 7, trendStr,        text_color=trendCol, text_size=size.tiny, text_halign=text.align_right)

// ══════════════════════════════════════════════════════════════════════════════
// ALERTS
// ══════════════════════════════════════════════════════════════════════════════

alertcondition(not na(ph), title="New Resistance Zone", message="New resistance zone created")
alertcondition(not na(pl), title="New Support Zone",    message="New support zone created")
alertcondition(bullFVG or bearFVG, title="FVG Zone",    message="Fair Value Gap zone detected")
alertcondition(chochBull or chochBear, title="CHoCH",   message="Change of Character — trend shift")
